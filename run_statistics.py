from stats.spc import spc
from stats.pnr import pnr
from stats.crp import crp
from stats.irt import irt
from glob import glob
import numpy as np
import json
import os


def run_stats():
    data_files = glob('/Users/jpazdera/Desktop/behavioral/beh_data_LTP[0-9][0-9][0-9].json') + \
                 glob('/Users/jpazdera/Desktop/behavioral/beh_data_LTP[0-9][0-9][0-9]_incomplete.json')

    stats = dict()
    for path in data_files:
        subj = os.path.basename(path)[9:15]
        try:
            with open(path, 'r') as f:
                # Run all stats for a single participant and add the resulting stats object to the stats dictionary
                stats[str(subj)] = stats_for_subj(json.load(f))
        except:
            print(subj)

    return stats


def stats_for_subj(data):

    sessions = np.array(data['session'])
    recalled = np.array(data['recalled'])
    spos = np.array(data['serialpos'])
    times = np.array(data['times'])
    intru = np.array(data['intrusions'])
    recw = np.array(data['rec_words'])
    ll = len(data['pres_nos'][0])

    stats = dict()
    stats['prec'] = prec(recalled, sessions)
    stats['spc'] = spc(spos, sessions, ll)
    stats['pfr'] = pnr(spos, sessions, ll, n=0)
    stats['psr'] = pnr(spos, sessions, ll, n=1)
    stats['ptr'] = pnr(spos, sessions, ll, n=2)
    stats['crp_early'] = crp(spos[:, :3], sessions, ll, lag_num=3)
    stats['crp_late'] = crp(spos[:, 2:], sessions, ll, lag_num=3)
    stats['irt'] = irt(times)
    stats['pli_early'] = avg_pli(intru[:, :3], sessions, recw)
    stats['pli_late'] = avg_pli(intru[:, 2:], sessions, recw)
    stats['eli_early'] = avg_eli(intru[:, :3], sessions)
    stats['eli_late'] = avg_eli(intru[:, 2:], sessions)
    stats['reps'] = avg_reps(spos, sessions)
    # stats['nback_pli_rate'] = nback_pli(intru, sessions, 6, recw)[0]

    # Fix CRPs to have a 0-lag of NaN
    stats['crp_early'][3] = np.nan
    stats['crp_late'][3] = np.nan

    return stats


def prec(was_recalled, subjects):
    """
    Calculate the overall probability of recall for each subject, given a lists x items matrix where 0s indicate
    words that were not subsequently recalled and 1s indicate words that were subsequently recalled. Item (i, j)
    should indicate whether the jth word presented in list i was recalled.

    :param was_recalled: A lists x items matrix, indicating whether each presented word was subsequently recalled
    :param subjects: A list of subject codes, indicating which subject produced each row of was_recalled
    :return: An array containing the overall probability of recall for each unique participant
    """
    if len(was_recalled) == 0:
        return np.array([]), np.array([])
    usub = np.unique(subjects)
    result = np.zeros(len(usub))
    stderr = np.zeros(len(usub))
    for i, s in enumerate(usub):
        result[i] = float(len(np.where(was_recalled[np.where(subjects == s)] == 1)[0])) / len(
            np.where(np.logical_not(np.isnan(was_recalled[np.where(subjects == s)])))[0])

    return result


def nback_pli(intrusions, subjects, nmax, rec_words):
    """
    Calculate the ratio of PLIs that originated from 1 list back, 2 lists back, etc. up until nmax lists back.

    :param intrusions: An intrusions matrix in the format generated by recalls_to_intrusions
    :param subjects: A list of subject codes, indicating which subject produced each row of the intrusions matrix
    :param nmax: The maximum number of lists back to consider
    :param rec_words: A lists x words matrix, where item (i, j) is the jth word presented on the ith list
    :return: An array of length nmax, where item i is the ratio of PLIs that originated from i+1 lists back
    """
    if len(intrusions) == 0 or nmax < 1:
        return np.array([])

    usub = np.unique(subjects)
    result = np.zeros((len(usub), nmax + 1), dtype=float)
    ll = len(intrusions[0])
    for i, s in enumerate(usub):
        for j in range(len(intrusions)):
            if subjects[j] == s:
                encountered = []
                for k in range(ll):
                    if intrusions[j][k] > 0 and rec_words[j][k] not in encountered:
                        encountered.append(rec_words[j][k])
                        if intrusions[j][k] <= nmax:
                            result[i, intrusions[j][k] - 1] += 1
                        else:
                            result[i, nmax] += 1

    result = result / np.atleast_2d(result.sum(axis=1)).T
    return result[:, :nmax]


def avg_pli(intrusions, subjects, rec_itemnos):
    """
    A modification of the behavioral toolbox's pli function. Calculate's each partcipant's average number of PLIs per
    list instead of their total number of PLIs.

    :param intrusions: An intrusions matrix in the format generated by recalls_to_intrusions
    :param subjects: A list of subject codes, indicating which subject produced each row of the intrusions matrix
    :param rec_itemnos: A matrix in which each row is the list of IDs for all words recalled by a single subject on a
                        single trial. Rows are expected to be padded with 0s to all be the same length.
    :return: An array where each entry is the average number of PLIs per list for a single participant.
    """
    usub = np.unique(subjects)
    result = np.zeros(len(usub))
    for subject_index in range(len(usub)):
        count = 0.
        lists = 0.
        for subj in range(len(subjects)):
            if subjects[subj] == usub[subject_index]:
                lists += 1
                encountered = []
                for serial_pos in range(len(intrusions[0])):
                    if intrusions[subj][serial_pos] > 0 and rec_itemnos[subj][serial_pos] not in encountered:
                        count += 1
                        encountered.append(rec_itemnos[subj][serial_pos])
        result[subject_index] = count / lists if lists > 0 else np.nan

    return result


def avg_eli(intrusions=None, subjects=None):
    """
    A modification of the behavioral toolbox's xli function. Calculate's each partcipant's average number of ELIs per
    list instead of their total number of ELIs.
    :param intrusions: An intrusions matrix in the format generated by recalls_to_intrusions
    :param subjects: A list of subject codes, indicating which subject produced each row of the intrusions matrix
    :return: An array where each entry is the average number of PLIs per list for a single participant.
    """
    usub = np.unique(subjects)
    result = np.zeros(len(usub))
    for subject_index in range(len(usub)):
        count = 0.
        lists = 0.
        for subj in range(len(subjects)):
            if subjects[subj] == usub[subject_index]:
                lists += 1
                for serial_pos in range(len(intrusions[0])):
                    if intrusions[subj][serial_pos] < 0:
                        count += 1
        result[subject_index] = count / lists if lists > 0 else np.nan
    return result


def avg_reps(rec_itemnos, subjects):
    """
    Calculate's each partcipant's average number of repetitions per list.

    :param rec_itemnos: A matrix in which each row is the list of IDs for all words recalled by a single subject on a
                        single trial. Rows are expected to be padded with 0s to all be the same length.
    :param subjects: A list of subject codes, indicating which subject produced each row of the intrusions matrix
    :return: An array where each entry is the average number of repetitions per list for a single participant.
    """
    usub = np.unique(subjects)
    result = np.zeros(len(usub))
    for subject_index in range(len(usub)):
        count = 0.
        lists = 0.
        for subj in range(len(subjects)):
            if subjects[subj] == usub[subject_index]:
                lists += 1
                # times_recalled is an array with one entry for each unique correctly recalled word, indicating the
                # number of times that word was recalled during the current list
                times_recalled = np.array(
                    [len(np.where(rec_itemnos[subj, :] == rec)[0]) for rec in np.unique(rec_itemnos[subj, :]) if
                     rec > 0])
                # Subtract 1 from the number of times each correct word was recalled in the list to give the number of
                # repetitions
                repetitions = times_recalled - 1
                # Sum the number of repetitions made in the current list
                count += repetitions.sum()
        result[subject_index] = count / lists if lists > 0 else np.nan
    return result


if __name__ == "__main__":
    run_stats()
